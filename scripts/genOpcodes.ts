import { writeFile } from "fs/promises";
import { dedent, entries } from "../utils/index.ts";

// TODO: the bytecode version matches, but I don't know which RN version discord uses
const HERMES_URL = "https://github.com/facebook/hermes/raw/refs/tags/v0.13.0";
const BYTECODE_URL = `${HERMES_URL}/include/hermes/BCGen/HBC/BytecodeList.def`;
const BUILTINS_URL = `${HERMES_URL}/include/hermes/FrontEndDefs/Builtins.def`;

const opcodes = {} as Record<string, string[]>;
const bigIntOps = {} as Record<string, number[]>;
const functionOps = {} as Record<string, number[]>;
const stringOps = {} as Record<string, number[]>;
const builtins = [] as string[];

parseBytecode(await fetch(BYTECODE_URL).then(res => res.text()));
parseBuiltins(await fetch(BUILTINS_URL).then(res => res.text()));

const src = dedent`\
  // auto-generated by genOpcodes.ts

  /**
   * Numeric Hermes instruction opcodes.
   */
  export enum Opcode { // {{{
  ${entries(opcodes).map(([op]) => `  ${op},`).join("\n")}
  } // }}}

  /**
   * Argument type corresponding to {@link Opcode}.
   */
  export const opcodeTypes = { // {{{
  ${entries(opcodes).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
  } as const; // }}}

  /**
   * Opcodes which have operands referring to the bigint table.
   */
  export const bigIntOperands = { // {{{
  ${entries(bigIntOps).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
  } as Record<Opcode, number[]>; // }}}

  /**
   * Opcodes which have operands referring to the function table.
   */
  export const functionOperands = { // {{{
  ${entries(functionOps).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
  } as Record<Opcode, number[]>; // }}}

  /**
   * Opcodes which have operands referring to the string table.
   */
  export const stringOperands = { // {{{
  ${entries(stringOps).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
  } as Record<Opcode, number[]>; // }}}

  export enum Builtin { // {{{
  ${builtins.map(x => `  ${stringify(x)},`).join("\n")}
  } // }}}

  export type ArgumentType = typeof opcodeTypes[Opcode][number];

  // vim\: set foldenable:
`;

writeFile("decompiler/src/opcodes.ts", src);

function parseBytecode(listing: string) {
    const OPCODE_RE = /^DEFINE_(\S+)_(\d)\((.*)\)$/gm;
    const OPERAND_RE = /^OPERAND_(\S+)_ID\((.*)\)$/gm;

    for (const [, dir, count, operands] of listing.matchAll(OPCODE_RE)) {
        const [op, ...args] = operands.split(/, */);

        if (dir == "OPCODE") {
            opcodes[op] = args;
        } else if (dir == "JUMP") {
            const args = Array.from(Array(+count - 1), () => "Reg8");
            opcodes[op] = ["Addr8", ...args];
            opcodes[op + "Long"] = ["Addr32", ...args];
        } else {
            throw Error(`Unknown definition: ${dir}`);
        }
    }

    for (const [, dir, operands] of listing.matchAll(OPERAND_RE)) {
        const [name, idx] = operands.split(/, */);

        if (dir == "BIGINT") (bigIntOps[name] ??= []).push(+idx);
        else if (dir == "FUNCTION") (functionOps[name] ??= []).push(+idx);
        else if (dir == "STRING") (stringOps[name] ??= []).push(+idx);
        else throw Error(`Unknown definition: ${dir}`);
    }
}

function parseBuiltins(listing: string) {
    const METHOD_RE = /^BUILTIN_METHOD\((.*)\)$/gm;
    const PRIVATE_RE = /^PRIVATE_BUILTIN\((.*)\)$/gm;

    for (const [, args] of listing.matchAll(METHOD_RE)) {
        const [obj, meth] = args.split(/, */);

        builtins.push(`${obj}.${meth}`);
    }

    for (const [, builtin] of listing.matchAll(PRIVATE_RE)) {
        builtins.push(builtin);
    }
}

function stringify(val: any) {
    return Array.isArray(val)
        ? `[${val.map(v => JSON.stringify(v)).join(", ")}]`
        : JSON.stringify(val);
}
