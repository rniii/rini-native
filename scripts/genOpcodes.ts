import { dedent, entries } from "../utils/index.ts";
import { writeFile } from "fs/promises";

// TODO: the bytecode version matches, but I don't know which RN version discord uses
const LISTING_URL =
  "https://github.com/facebook/hermes/raw/refs/tags/v0.13.0/include/hermes/BCGen/HBC/BytecodeList.def";
const OPCODE_RE = /^DEFINE_(\S+)_(\d)\((.*)\)$/gm;
const OPERAND_RE = /^OPERAND_(\S+)_ID\((.*)\)/gm;

const opcodes = {} as Record<string, string[]>;
const bigIntOps = {} as Record<string, number[]>;
const functionOps = {} as Record<string, number[]>;
const stringOps = {} as Record<string, number[]>;

const listing = await fetch(LISTING_URL).then(res => res.text());

for (const [, dir, count, operands] of listing.matchAll(OPCODE_RE)) {
  const [op, ...args] = operands.split(/, */);

  if (dir == "OPCODE") {
    opcodes[op] = args;
  } else if (dir == "JUMP") {
    const args = Array.from(Array(+count - 1), () => "Reg8");
    opcodes[op] = ["Addr8", ...args];
    opcodes[op + "Long"] = ["Addr32", ...args];
  } else {
    throw Error(`Unknown definition: ${dir}`);
  }
}

for (const [, dir, operands] of listing.matchAll(OPERAND_RE)) {
  const [name, idx] = operands.split(/, */);

  if (dir == "BIGINT") (bigIntOps[name] ??= []).push(+idx);
  else if (dir == "FUNCTION") (functionOps[name] ??= []).push(+idx);
  else if (dir == "STRING") (stringOps[name] ??= []).push(+idx);
  else throw Error(`Unknown definition: ${dir}`);
}

const stringify = (val: any) =>
  Array.isArray(val)
    ? `[${val.map(v => JSON.stringify(v)).join(", ")}]`
    : JSON.stringify(val);

const src = dedent`\
  // auto-generated by genOpcodes.ts

  /**
   * Numeric Hermes instruction opcodes.
   */
  export enum Opcode { // {{{
  ${entries(opcodes).map(([op]) => `  ${op},`).join("\n")}
  } // }}}

  /**
   * Argument type corresponding to {@link Opcode}.
   */
  export const opcodeTypes = { // {{{
  ${entries(opcodes).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
  } as const; // }}}

  /**
   * Opcodes which have operands referring to the bigint table.
   */
  export const bigIntOperands = { // {{{
  ${entries(bigIntOps).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
  } as Record<Opcode, number[]>; // }}}

  /**
   * Opcodes which have operands referring to the function table.
   */
  export const functionOperands = { // {{{
  ${entries(functionOps).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
  } as Record<Opcode, number[]>; // }}}

  /**
   * Opcodes which have operands referring to the string table.
   */
  export const stringOperands = { // {{{
  ${entries(stringOps).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
  } as Record<Opcode, number[]>; // }}}

  export type ArgumentType = typeof opcodeTypes[Opcode][number];

  // vim\: set foldenable:
`;

writeFile("decompiler/src/opcodes.ts", src);
